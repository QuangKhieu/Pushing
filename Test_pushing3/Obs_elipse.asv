classdef Obs_elipse < handle
    %OBS Summary of this class goes here
    %obs elipse shape
    %   Detailed explanation goes here
   properties (Constant = true)
        p_ỏi
        so_xy = Obs.make_shape(Obs.p_x, Obs.p_y); % 2*N
        env = Env() ;
        m = 2;
        I = 1;
   end
    properties
        
        p=[0 0];
        v= [0 0];  
        heading = 0;
        omega = 0;
        f = [0 0];%(m*2) m hang 2 cot
        a = [0 0];
        a_ht = 0; %d(omega)/dt
        s_xy = Obs.make_shape(Obs.p_x, Obs.p_y); % 2*N
        p_co;

    end
    
    methods (Static)
        %Khối obs
        function s_xy = make_shape(p_x, p_y)
            % Nối điểm
            p_x = [p_x, p_x(1)];
            p_y = [p_y, p_y(1)];

            s_x = [];
            s_y = [];


            for j = 1:length(p_x)-1
                [l_x, l_y] = make_line([p_x(j), p_y(j)],[p_x(j+1)- p_x(j), p_y(j+1) - p_y(j)]);%tao cac diem nam gia 2 diem 
                s_x = [s_x, l_x];
                s_y = [s_y, l_y];
            end
            s_xy = [s_x;s_y];
            function [m_x, m_y]=make_line(po,vec)

                % creat point square
                delta_l = 0.0005;
                angel = atan2(vec(2), vec(1));
                delta_x = delta_l*cos(angel);
                delta_y = delta_l*sin(angel);


                m_x = [];
                m_y = [];
                % chia doan thang thanh nhung diem nho
                for i = 1:floor(norm(vec)/delta_l)
                    m_x = [m_x, po(1)+delta_x*i];
                    m_y = [m_y, po(2)+delta_y*i];
                end
            end
        end
    end
    
    methods
        function obj = Obs(number)
            if nargin == 1
                obj.f = zeros(number,2);
            end
            
        end

       
       
        function update_aV(obj, dt)
           %cal sum F 
            sum_f = [sum(obj.f(:,1)),sum(obj.f(:,2))]; % tong hop luc
 
            %update V
            if norm(obj.v) ~= 0
               % cal a
               obj.a = (sum_f - obj.env.muy0_t * obj.m*obj.v/norm(obj.v) ...
                  -  obj.env.muy1_t*obj.v) / obj.m;
               v_ = obj.v + obj.a * dt;
               
                
            else
               obj.a = sum_f / obj.m;
               v_ = obj.v + obj.a * dt;                
                
            end
            
            %cali
            
            if (v_(1)*obj.v(1) < 0)
                obj.v(1) = 0;
            else
                obj.v(1) = v_(1);
            end
            
            if (v_(2)*obj.v(2) < 0)
                obj.v(2) = 0;
            else
                obj.v(2) = v_(2);
            end
            
            %update omega
            %sum moment
            
            r_vec = obj.p_co-obj.p ;%n*2 (n la so robot)
            % cross matrix f vs matrix r
                  
            cros = cross([r_vec'; zeros(1, height(r_vec))],...
                [obj.f' ; zeros(1,height(r_vec))]);
            
            sum_cf = sum(cros(3,:))  ;  
            norm(obj.omega);
            if norm(obj.omega) ~= 0
                obj.a_ht = (sum_cf...
                    - obj.env.muy0_r*obj.I*obj.omega/norm(obj.omega)...
                    - obj.env.muy1_r*obj.omega) / obj.I;
                omega_ = obj.omega + obj.a_ht * dt;
            else
                obj.a_ht = sum_cf / obj.I;
                omega_ = obj.omega + obj.a_ht * dt;
            end
%             obj.omega = omega_;
%             
            
            if omega_*obj.omega < 0
                obj.omega = 0;
            else
                obj.omega = omega_;
            end
            
        end
        %update p 
        function updatePO(obj, dt) 
            %cal PO of center obs
            obj.p = obj.p + obj.v*dt;
            obj.heading = obj.heading + obj.omega*dt;
            
            %update PO of eadge
            head = obj.heading;
            pos = obj.p;
            matrix_t = [cos(head) -sin(head) pos(1) ;...
                          sin(head) cos(head) pos(2);...
                          0            0        1   ];
             for i = 1:length(obj.so_xy)
                no = (matrix_t)*[obj.so_xy(1,i); obj.so_xy(2,i);1];
                obj.s_xy(1,i) = no(1);
                obj.s_xy(2,i) = no(2);
             end
        end


    end
end

